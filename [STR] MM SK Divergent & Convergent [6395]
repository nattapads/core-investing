//NSal
//@version=6
strategy('[STR] MM SK Divergent & Convergent [6395]', overlay = true, margin_long = 50, margin_short = 50, pyramiding = 100, initial_capital = 1000000, risk_free_rate = 1, commission_value = 0.165, slippage = 1)

//-----------------------------------------------------------------------------}
//Settings
//-----------------------------------------------------------------------------{
startTime = input.time(timestamp('Jan 01 1970 00:00:00'), title = 'Start Time')
inTimeWindow = time >= startTime

//-----------------------------------------------------------------------------}
//Momentum  Settings
//-----------------------------------------------------------------------------{
moProp = input.float(0.20, maxval = 1.00, step = 0.1, title = 'Momentum Weight (%)', group = 'Momentum Settings')
rapidMoScalar = input.float(5.647098012, step = 0.01, title = 'EMA 8 Scalar', group = 'Momentum Settings')
fastMoScalar = input.float(3.983385264, step = 0.01, title = 'EMA 16 Scalar', group = 'Momentum Settings')
mediumMoScalar = input.float(2.823445806, step = 0.01, title = 'EMA 32 Scalar', group = 'Momentum Settings')
slowMoScalar = input.float(2.071579913, step = 0.01, title = 'EMA 64 Scalar', group = 'Momentum Settings')
zeroLag = input(false, title = 'Acceleration-Adjusted Momentum', group = 'Momentum Settings')

//-----------------------------------------------------------------------------}
//Acceleration Settings
//-----------------------------------------------------------------------------{
acProp = input.float(0.20, maxval = 1.00, step = 0.1, title = 'Acceleration Weight (%)', group = 'Acceleration Settings')
acFastScalar = input.float(1.444841216, step = 0.01, title = 'EMA 16 Acceleration Scalar', group = 'Acceleration Settings')
acMediumScalar = input.float(1.45027532, step = 0.01, title = 'EMA 32 Acceleration Scalar', group = 'Acceleration Settings')
acSlowScalar = input.float(1.418962145, step = 0.01, title = 'EMA 64 Acceleration Scalar', group = 'Acceleration Settings')

//-----------------------------------------------------------------------------}
//Breakout  Settings
//-----------------------------------------------------------------------------{
boProp = input.float(0.20, maxval = 1.00, step = 0.1, title = 'Breakout Weight (%)', group = 'Breakout Settings')
bo20Scalar = input.float(1.021079839, step = 0.01, title = 'Breakout 20 Scalar', group = 'Breakout Settings')
bo40Scalar = input.float(1.02042493, step = 0.01, title = 'Breakout 40 Scalar', group = 'Breakout Settings')
bo80Scalar = input.float(1.015075907, step = 0.01, title = 'Breakout 80 Scalar', group = 'Breakout Settings')

//-----------------------------------------------------------------------------}
//Skew  Settings
//-----------------------------------------------------------------------------{
skProp = input.float(0.20, maxval = 1.0, step = 0.1, title = 'Skew Proportion (%)', group = 'Skew Settings')
sk60Scalar = input.float(22.7241469, step = 0.1, title = 'Skew 60 Scalar', group = 'Skew Settings')
sk120Scalar = input.float(23.233971, step = 0.1, title = 'Skew 120 Scalar', group = 'Skew Settings')
sk240Scalar = input.float(24.39380478, step = 0.1, title = 'Skew 240 Scalar', group = 'Skew Settings')

//-----------------------------------------------------------------------------}
//Carry Settings
//-----------------------------------------------------------------------------{
crProp = input.float(0.20, maxval = 1.00, step = 0.1, title = 'Carry Weight (%)', group = 'Carry Settings', tooltip = 'Higher proportion causes higher percent risk')
crScalar = input.float(30, step = 0.01, title = 'Carry Scalar', group = 'Carry Settings')
dividendSchedule = input.string('Quarterly', title = 'Dividend Payment Frequency', options = ['Annual', 'Semi-Annual', 'Quarterly', 'Monthly'], group = 'Carry Settings')
manDiv = input.float(0.02, step = 0.01, title = 'Manual Dividend Yield (%)', group = 'Carry Settings')
enableManDiv = input(false, title = 'Enable Manual Dividend Yield', group = 'Carry Settings')
dividend = request.dividends(syminfo.tickerid)
instruName = syminfo.ticker

//Dividen Calculation
//-----------------------------------------------------------------------------{
var dividendFrequency = 0
if dividendSchedule == 'Annual'
    dividendFrequency := 1
    dividendFrequency
else if dividendSchedule == 'Semi-Annual'
    dividendFrequency := 2
    dividendFrequency
else if dividendSchedule == 'Quarterly'
    dividendFrequency := 4
    dividendFrequency
else
    dividendFrequency := 12
    dividendFrequency

//Experted Dividend Calcaulation
//-----------------------------------------------------------------------------{
rawDiv = enableManDiv ? manDiv : dividend * dividendFrequency / close
expectedDiv = na(rawDiv) ? manDiv : rawDiv

if instruName == 'GLD' or instruName == 'BTCUSD'
    expectedDiv := 0

//-----------------------------------------------------------------------------}
//Risk Settings
//-----------------------------------------------------------------------------{
expoStdLength = input.int(32, title = 'Exponential SD Length', group = 'Risk Settings')
avgStdLength = input.int(2560, title = 'Average SD Length', group = 'Risk Settings', tooltip = '10 years average = 2560 bars in D Timeframe')
mmRiskPct = input.float(0.045, 'Risk per Trade (%)', step = 0.005, group = 'Risk Settings', tooltip = 'Conservative: 1-2%, Balance: 3-4%, Aggressive: 5%+')
deviationChange = input.float(0.1, maxval = 1, step = 0.1, title = 'Change Sensitivity (%)', group = 'Risk Settings', tooltip = 'Higher sensitivity causes less frequent trades, and lower trading costs')
forcastDiverMuliplier = input.float(1.4, step = 0.01, title = 'Forecast Diversification Multiplier', group = 'Risk Settings')
capAdjust = input.int(10, title = 'Capped-Forecast Adjustment', group = 'Risk Settings')
upperForeCap = input.int(10, title = 'Upper Forecast Cap', group = 'Risk Settings')
lowerForeCap = input.int(-10, title = 'Lower Forecast Cap', group = 'Risk Settings')
riskFree = input.float(0.01, step = 0.01, title = 'Risk-free Rate (%)', group = 'Risk Settings')
useMarginAcc = input(false, title = 'Margin Account', group = 'Risk Settings')

//-----------------------------------------------------------------------------{
//Instrument Risk Calculation
//-----------------------------------------------------------------------------{
// Percentage returns
ret = (close - close[1]) / close[1]
var float dailyPercentVolRecent = na

ew_var = ta.ema(math.pow(ret, 2), expoStdLength)
dailyPercentVolRecent := math.sqrt(ew_var)

// Long-term vol  (10-year ≈ 2560 bars)
dailyPercentVol8Yr = ta.sma(dailyPercentVolRecent, avgStdLength)

// Weighted blend 70 / 30
dailyPercentVol = 0.7 * dailyPercentVolRecent + 0.3 * dailyPercentVol8Yr

// Instrument risk & price-vol units (same as original)
instRisk      = math.round(dailyPercentVol * 16, 6)
dailyPriceVol = dailyPercentVol * close

//-----------------------------------------------------------------------------
//Common cap helper
//-----------------------------------------------------------------------------
cap(_x) =>
    math.max(lowerForeCap, math.min(upperForeCap, _x))

//-----------------------------------------------------------------------------
//Momentum Calculation
//-----------------------------------------------------------------------------
momentumForcCal(len, multiplier) =>
    int emaLen = math.max(1, int(len * multiplier))

    ema_ = ta.ema(close, emaLen)

    zeroLag ? ema_ + (ema_ - ta.ema(ema_, emaLen)) : ema_

rapidMoLength  = 8
fastMoLength   = 16
mediumMoLength = 32
slowMoLength   = 64

rapidEma   = momentumForcCal(rapidMoLength, 1)
rapidSEma  = momentumForcCal(rapidMoLength, 4)
fastEma    = momentumForcCal(fastMoLength, 1)
fastSEma   = momentumForcCal(fastMoLength, 4)
mediumEma  = momentumForcCal(mediumMoLength, 1)
mediumSEma = momentumForcCal(mediumMoLength, 4)
slowEma    = momentumForcCal(slowMoLength, 1)
slowSEma   = momentumForcCal(slowMoLength, 4)

//-----------------------------------------------------------------------------
//Momentum Forecast
//-----------------------------------------------------------------------------
scalForecastMo(_fastEma, _slowEma, _volatility, _scalar) =>
    riskAdjusted   = (_fastEma - _slowEma) / _volatility
    scaledForecast = riskAdjusted * _scalar
    scaledForecast

scaledForcR = scalForecastMo(rapidEma,  rapidSEma,  dailyPriceVol, rapidMoScalar)
scaledForcF = scalForecastMo(fastEma,   fastSEma,   dailyPriceVol, fastMoScalar)
scaledForcM = scalForecastMo(mediumEma, mediumSEma, dailyPriceVol, mediumMoScalar)
scaledForcS = scalForecastMo(slowEma,   slowSEma,   dailyPriceVol, slowMoScalar)

// Capped Momentum
cappedForcR = cap(scaledForcR)
cappedForcF = cap(scaledForcF)
cappedForcM = cap(scaledForcM)
cappedForcS = cap(scaledForcS)

//-----------------------------------------------------------------------------
//Acceleration Forecast
//-----------------------------------------------------------------------------
capForecastAc(offsetLen, _scaledForc, forecastAcScalar) =>
    forcAc       = _scaledForc - _scaledForc[offsetLen]
    scaledForcAc = forcAc * forecastAcScalar
    cap(scaledForcAc)

cappedForcFAc = capForecastAc(fastMoLength,   scaledForcF, acFastScalar)
cappedForcMAc = capForecastAc(mediumMoLength, scaledForcM, acMediumScalar)
cappedForcSAc = capForecastAc(slowMoLength,   scaledForcS, acSlowScalar)

//-----------------------------------------------------------------------------
//Breakout Forecast
//-----------------------------------------------------------------------------
capForecastBo(breakLen, forecastScalar) =>
    hi    = ta.highest(high, breakLen)
    lo    = ta.lowest(low, breakLen)
    rangeBo = hi - lo

    boRaw = rangeBo != 0.0 ? 40.0 * (close - (hi + lo) / 2.0) / rangeBo : 0.0

    int smoothLen   = math.max(1, int(breakLen / 4))
    smoothForcBo    = ta.ema(boRaw, smoothLen)
    scaledForcBo    = smoothForcBo * forecastScalar
    cap(scaledForcBo)

cappedForcBo20 = capForecastBo(20, bo20Scalar)
cappedForcBo40 = capForecastBo(40, bo40Scalar)
cappedForcBo80 = capForecastBo(80, bo80Scalar)

//-----------------------------------------------------------------------------}
//Skew Forcast Calculation
//-----------------------------------------------------------------------------{
capforecastSk(len, scalar) =>
    int length = math.max(len, 2)

    float sumR  = 0.0
    float sumR2 = 0.0
    float sumR3 = 0.0

    for i = 0 to length - 1
        float roc = (close[i] - close[i + 1]) / close[i + 1]
        sumR  += roc
        sumR2 += roc * roc
        sumR3 += roc * roc * roc

    float n   = length
    float mean = sumR / n
    float m2   = sumR2 / n
    float m3   = sumR3 / n
    float mu3 = m3 - 3.0 * mean * m2 + 2.0 * math.pow(mean, 3.0)
    float variance = m2 - mean * mean
    float stdv     = variance > 0 ? math.sqrt(variance) : na
    float skewForc = not na(stdv) and stdv != 0.0 ? -mu3 / math.pow(stdv, 3.0) : 0.0

    int   smoothLengthSk = math.max(1, length / 4)
    float smoothSkForc   = ta.ema(skewForc, smoothLengthSk)
    float scaledForSk    = smoothSkForc * scalar

    float capped =
         scaledForSk <= lowerForeCap ? lowerForeCap :
         scaledForSk >= upperForeCap ? upperForeCap :
                              scaledForSk

    capped

CappedForcSk60 = capforecastSk(60, sk60Scalar)
CappedForcSk120 = capforecastSk(120, sk120Scalar)
CappedForcSk240 = capforecastSk(240, sk240Scalar)

//-----------------------------------------------------------------------------
//Carry Forecast
//-----------------------------------------------------------------------------
capForecastCr(smoothLen, baseCrForc) =>
    scaledForcCr = ta.ema(baseCrForc, smoothLen)
    cap(scaledForcCr)

baseCrForc = expectedDiv * crScalar / instRisk

cappedForcCr20  = capForecastCr(20,  baseCrForc)
cappedForcCr60  = capForecastCr(60,  baseCrForc)
cappedForcCr120 = capForecastCr(120, baseCrForc)

//-----------------------------------------------------------------------------
//All Forecast Combination
//-----------------------------------------------------------------------------
cappedForcMo = (cappedForcR + cappedForcF + cappedForcM + cappedForcS) / 4.0
cappedForcAc = (cappedForcFAc + cappedForcMAc + cappedForcSAc) / 3.0
cappedForcBo = (cappedForcBo20 + cappedForcBo40 + cappedForcBo80) / 3.0
cappedForcCr = (cappedForcCr20 + cappedForcCr60 + cappedForcCr120) / 3.0
cappedForcSk = (CappedForcSk60 + CappedForcSk120 + CappedForcSk240) / 3.0

//-----------------------------------------------------------------------------
//Combined Forecast + Capping
//-----------------------------------------------------------------------------
combForc = cappedForcMo * moProp + cappedForcAc * acProp + cappedForcBo * boProp + cappedForcCr * crProp + cappedForcSk * skProp
scalCombForc = combForc * forcastDiverMuliplier

cappedCombForc = cap(scalCombForc)
adjCombForc = useMarginAcc ? cappedCombForc / 10.0 : cappedCombForc / capAdjust

//-----------------------------------------------------------------------------}
//Base Position
//-----------------------------------------------------------------------------{
capitalRisk = strategy.equity * mmRiskPct

basePos = dailyPriceVol > 0 ? capitalRisk / dailyPriceVol : 0.0
rawOptimalPosition = basePos * adjCombForc

optimalPosition = rawOptimalPosition > 0 ? math.round(rawOptimalPosition) : rawOptimalPosition < 0 ? math.round(rawOptimalPosition) : 0

//Buffer Zone
//-----------------------------------------------------------------------------{
bufferWidth = deviationChange * math.abs(basePos)
lowerBuffer = math.round(optimalPosition - bufferWidth, 0)
upperBuffer = math.round(optimalPosition + bufferWidth, 0)

currentSize = strategy.position_size

//Position Adjustment Signal & Position
//-----------------------------------------------------------------------------{
maxCapital = ((strategy.initial_capital + strategy.netprofit) - (currentSize * close))
maxPositionSize = maxCapital / close

buyQty = math.abs(math.round(lowerBuffer - currentSize, 0))
adjBuyQty = math.abs(math.round(currentSize - upperBuffer, 0))

Buy = useMarginAcc ? optimalPosition > 0 and optimalPosition > currentSize and currentSize < lowerBuffer and buyQty >= 1 and maxPositionSize >= 1 : optimalPosition > 0 and currentSize < lowerBuffer and buyQty >= 1 and strategy.equity > (currentSize + buyQty) * close
adjustBuy = currentSize > 0 and currentSize > upperBuffer and adjBuyQty >= 1

//Current Proportion
//-----------------------------------------------------------------------------{
currentHoldingValue = strategy.position_size * close
currentProportion = math.round(currentHoldingValue / strategy.equity, 2)

//-----------------------------------------------------------------------------}
//Strategy Execution
//-----------------------------------------------------------------------------{ 
if Buy and inTimeWindow
    strategy.entry('B', strategy.long, qty = buyQty)
else if adjustBuy and inTimeWindow
    strategy.close('B', qty = adjBuyQty)

//-----------------------------------------------------------------------------}
// Calculate Strategy Performance
//-----------------------------------------------------------------------------{
// Average Drawdown per Trade
//-----------------------------------------------------------------------------
avgTradeDrawdown() =>
    trades = strategy.closedtrades
    float sumAll  = 0.0
    float sumWin  = 0.0
    float sumLoss = 0.0
    int   nWin    = 0
    int   nLoss   = 0

    if trades == 0
        [na, na, na]
    else
        for i = 0 to trades - 1
            ddCurr   = strategy.closedtrades.max_drawdown(i)
            posValue = math.abs(strategy.closedtrades.entry_price(i) * strategy.closedtrades.size(i))

            ddPerc = posValue != 0 ? math.abs(ddCurr) / posValue : na

            if not na(ddPerc)
                sumAll += ddPerc

                isWin = strategy.closedtrades.profit(i) >= 0
                if isWin
                    sumWin += ddPerc
                    nWin   += 1
                else
                    sumLoss += ddPerc
                    nLoss   += 1

        float avgAll  = trades > 0 ? sumAll  / trades : na
        float avgWin  = nWin   > 0 ? sumWin  / nWin   : na
        float avgLoss = nLoss  > 0 ? sumLoss / nLoss  : na

        [avgAll, avgWin, avgLoss]

[avgTradeDD, avgTradeWinDD, avgTradeLossDD] = avgTradeDrawdown()

// Annual Return Calcaulation
// -----------------------------------------------------------------------------
var int firstTradeTime = na
hasPosition = strategy.opentrades + strategy.closedtrades > 0

if hasPosition and na(firstTradeTime)
    firstTradeTime := time

yearsActive = (time - firstTradeTime) / (365.25 * 24 * 60 * 60 * 1000)
enoughTime  = yearsActive > 0
totReturn   = strategy.netprofit / strategy.initial_capital
avgAnnualReturn   = enoughTime ? (totReturn / yearsActive) * 100 : na
rawAvgAnnualReturn = avgAnnualReturn / 100

avgDD = avgTradeDD

//Sharpe Ratio
//-----------------------------------------------------------------------------
float barsPerYear = na

if timeframe.isdaily
    barsPerYear := 256
else if timeframe.isweekly
    barsPerYear := 52
else if timeframe.ismonthly
    barsPerYear := 12
else
    tfNum = str.tonumber(timeframe.period)
    barsPerDay = not na(tfNum) and tfNum > 0 ? 390.0 / tfNum : 0.0
    barsPerYear := 256.0 * barsPerDay

var float sumRet   = 0.0
var float sumSqRet = 0.0
var int   nRet     = 0

canRecordSharpe = not na(firstTradeTime) and time > firstTradeTime

if canRecordSharpe and not na(strategy.equity) and not na(strategy.equity[1]) and barsPerYear > 0
    r = strategy.equity / strategy.equity[1] - 1.0

    sumRet   += r
    sumSqRet += r * r
    nRet     += 1

meanBar = nRet > 0 ? sumRet / nRet : na
varBar  = nRet > 0 ? (sumSqRet / nRet) - (meanBar * meanBar) : na
stdBar  = not na(varBar) and varBar > 0 ? math.sqrt(varBar) : na

rf_bar = riskFree / barsPerYear
excess_bar = not na(meanBar) ? meanBar - rf_bar : na

sharpeRatio = not na(stdBar) and stdBar > 0 and not na(excess_bar) ?
     excess_bar / stdBar * math.sqrt(barsPerYear) :
     na

//Table Styling
//-----------------------------------------------------------------------------{ 
bgMColour = color.rgb(0, 0, 0, 30)
bgSColour = color.rgb(0, 0, 0, 20)

if strategy.netprofit > 0
    bgMColour := color.rgb(8, 153, 129)
    bgSColour := color.rgb(8, 153, 129, 20)
    bgSColour
else
    bgMColour := color.rgb(242, 54, 69)
    bgSColour := color.rgb(242, 54, 69, 20)
    bgSColour

//-----------------------------------------------------------------------------}
//Performance Table
//-----------------------------------------------------------------------------{ 
table_data = table.new(position = position.top_right, columns = 1, rows = 8, bgcolor = color.rgb(0, 0, 0, 100), frame_width = 1, border_width = 1)

table.cell(table_data, 0, 0, 'TDC782', bgcolor = color.rgb(255, 255, 255, 70), text_size = size.normal, text_color = color.rgb(255, 255, 255))
table.cell(table_data, 0, 1, str.tostring(avgAnnualReturn, format.percent), text_size = size.normal, bgcolor = bgMColour, text_color = color.rgb(255, 255, 255), text_halign = text.align_center, tooltip = 'Average Annual Return')
table.cell(table_data, 0, 2, str.tostring(math.round(sharpeRatio, 3)), text_size = size.normal, bgcolor = bgSColour, text_color = color.rgb(255, 255, 255), text_halign = text.align_center, tooltip = 'Sharpe Ratio')
table.cell(table_data, 0, 3, str.tostring(avgDD * 100, format.percent), text_size = size.normal, bgcolor = color.rgb(242, 54, 69, 30), text_color = color.rgb(255, 255, 255), text_halign = text.align_center, tooltip = 'Average Drawdown per Trade')
table.cell(table_data, 0, 4, str.tostring(expectedDiv * 100, format.percent), bgcolor = color.rgb(255, 255, 255, 80), text_size = size.normal, text_color = color.rgb(255, 255, 255), tooltip = 'Dividend Yield')
table.cell(table_data, 0, 5, str.tostring(math.round(adjCombForc, 2)), bgcolor = color.rgb(255, 255, 255, 90), text_size = size.normal, text_color = color.rgb(255, 255, 255), tooltip = 'Forecast')
table.cell(table_data, 0, 6, str.tostring(instRisk * 100, format.percent), text_size = size.normal, bgcolor = color.rgb(242, 54, 70, 70), text_color = color.rgb(255, 255, 255), text_halign = text.align_center, tooltip = 'Standard Deviation')
table.cell(table_data, 0, 7, str.tostring(currentProportion * 100, format.percent), bgcolor = color.rgb(255, 255, 255, 90), text_size = size.normal, text_color = color.rgb(255, 255, 255), tooltip = 'Percent Risk')

//-----------------------------------------------------------------------------}
//Entry & Exit Signal
//-----------------------------------------------------------------------------{
plotshape(Buy, title = 'Initial Buy', text = '▲', textcolor = color.white, style = shape.labelup, location = location.belowbar, color = color.rgb(8, 153, 129, 70), size = size.tiny)
plotshape(adjustBuy, title = 'Adjust Sell', text = '✘', textcolor = color.white, style = shape.labeldown, location = location.abovebar, color = color.rgb(242, 54, 69, 70), size = size.tiny)

//-----------------------------------------------------------------------------}
//Bar & Trend Line Colours
//-----------------------------------------------------------------------------{
neutralColor = #56328f
strongbullColor = color.rgb(8, 153, 129)
bullColor = color.rgb(8, 153, 129, 50)
strongBearishColor = color.rgb(242, 54, 69)
bearColor = color.rgb(242, 54, 69, 50)

//-----------------------------------------------------------------------------}
//Momentum Filter Calculation
//-----------------------------------------------------------------------------{
strongBullish = adjCombForc > 0 and adjCombForc > adjCombForc[1]
strongBearish = adjCombForc < 0 and adjCombForc < adjCombForc[1]
bullish = adjCombForc > 0 and adjCombForc < adjCombForc[1]
bearish = adjCombForc < 0 and adjCombForc > adjCombForc[1]

//Bar Colour
//-----------------------------------------------------------------------------{
barcolor(strongBullish ? strongbullColor : strongBearish ? strongBearishColor : bullish ? bullColor : bearish ? bearColor : neutralColor)

//-----------------------------------------------------------------------------}
//Alert
//-----------------------------------------------------------------------------{
if Buy or adjustBuy
    alert('Position Adjusted', alert.freq_once_per_bar_close)
