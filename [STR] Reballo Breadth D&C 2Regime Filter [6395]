//NSal
//@version=6
strategy('[STR] Reballo Breadth D&C 2Regime Filter [6395]', overlay = true, pyramiding = 100, initial_capital = 1000000, risk_free_rate = 1, commission_value = 0.165, slippage = 1)

//=============================================================================
// INPUTS
//=============================================================================

// Time
startTime    = input.time(timestamp('Jan 01 2008 00:00:00'), title = 'Start Time')
inTimeWindow = time >= startTime

// Momentum
GRP_MO         = 'Momentum Settings'
rapidMoScalar  = input.float(7.54001034850941, step = 0.01, title = 'EMA 8 Scalar',  group = GRP_MO)
fastMoScalar   = input.float(5.20390597685097, step = 0.01, title = 'EMA 16 Scalar', group = GRP_MO)
mediumMoScalar = input.float(3.5366512640215, step = 0.01, title = 'EMA 32 Scalar', group = GRP_MO)
slowMoScalar   = input.float(2.43740709499241, step = 0.01, title = 'EMA 64 Scalar', group = GRP_MO)

// Acceleration
GRP_AC         = 'Acceleration Settings'
acFastScalar   = input.float(1.54054339703763, step = 0.01, title = 'EMA 16 Acceleration Scalar', group = GRP_AC)
acMediumScalar = input.float(1.58183429403401, step = 0.01, title = 'EMA 32 Acceleration Scalar', group = GRP_AC)
acSlowScalar   = input.float(1.52080269036627, step = 0.01, title = 'EMA 64 Acceleration Scalar', group = GRP_AC)

// Breakout
GRP_BO     = 'Breakout Settings'
bo20Scalar = input.float(0.876876349504234, step = 0.01, title = 'Breakout 20 Scalar', group = GRP_BO)
bo40Scalar = input.float(0.905313235788902, step = 0.01, title = 'Breakout 40 Scalar', group = GRP_BO)
bo80Scalar = input.float(0.904776229871206, step = 0.01, title = 'Breakout 80 Scalar', group = GRP_BO)

// Breadth Level
GRP_BR       = 'Breadth Settings'
brScalar     = input.float(40.0, 'Breadth Scalar', step = 0.1, group = GRP_BR)
mkt          = input.string(defval = "Combined", title = "Market", options = ["Combined", "NYSE", "NASDAQ", "AMEX"], group = GRP_BR, tooltip = "0=>Combined, 1=>NYSE, 2=>NASDAQ, 3=>AMEX, 4=>CUSTOM")

// Inverse Breadth for Gold
brScalar := syminfo.ticker == "IAU" or syminfo.ticker == "GLD" or syminfo.ticker == "IAUI" ? -math.abs(brScalar) : brScalar

// Skew
GRP_SK      = 'Skew Settings'
sk60Scalar  = input.float(21.5455286802638,  step = 0.1, title = 'Skew 60 Scalar',  group = GRP_SK)
sk120Scalar = input.float(22.8063794468406, step = 0.1, title = 'Skew 120 Scalar', group = GRP_SK)
sk240Scalar = input.float(22.9508040770949, step = 0.1, title = 'Skew 240 Scalar', group = GRP_SK)

// Carry
GRP_CR           = 'Carry Settings'
crScalar         = input.float(30, step = 0.01, title = 'Carry Scalar', group = GRP_CR)
dividendSchedule = input.string('Quarterly', title = 'Dividend Payment Frequency', options = ['Annual', 'Semi-Annual', 'Quarterly', 'Monthly'], group = GRP_CR)
manDiv           = input.float(0.02, step = 0.01, title = 'Manual Dividend Yield (%)', group = GRP_CR)
enableManDiv     = input(false, title = 'Enable Manual Dividend Yield', group = GRP_CR)

// Risk
GRP_RK                = 'Risk Settings'
expoStdLength         = input.int(32, title = 'Exponential SD Length', group = GRP_RK)
avgStdLength          = input.int(2560, title = 'Average SD Length', group = GRP_RK)
mmRiskPct             = input.float(0.02, 'Risk per Trade (%)', step = 0.005, group = GRP_RK)
deviationChange       = input.float(0.1, maxval = 1, step = 0.1, title = 'Change Sensitivity (%)', group = GRP_RK, tooltip = 'Higher sensitivity causes less frequent trades')
forcastDiverMuliplier = input.float(1.44, step = 0.01, title = 'Forecast Diversification Multiplier', group = GRP_RK)
upperForeCap          = input.int(20, title = 'Upper Forecast Cap', group = GRP_RK)
lowerForeCap          = input.int(-20, title = 'Lower Forecast Cap', group = GRP_RK)
minHold               = input.float(0.0, step = 0.05, title = 'Minimum Holding', group = GRP_RK)

//=============================================================================
// HELPER FUNCTIONS
//=============================================================================

cap(float x) =>
    math.max(lowerForeCap, math.min(upperForeCap, x))

capadj(float x) =>
    math.max(minHold, math.min(upperForeCap / 10.0, x))

//=============================================================================
// DIVIDED YIELD
//=============================================================================

dividend   = request.dividends(syminfo.tickerid)
instruName = syminfo.ticker

dividendFrequency = dividendSchedule == 'Annual' ? 1 : dividendSchedule == 'Semi-Annual' ? 2 : dividendSchedule == 'Quarterly' ? 4 : 12

rawDiv         = enableManDiv ? manDiv : dividend * dividendFrequency / close
expectedDiv    = na(rawDiv) ? manDiv : rawDiv
noDiv          = instruName == 'IAU' or instruName == 'BTCUSD'
adjExpectedDiv = noDiv ? 0.0 : expectedDiv

//=============================================================================
// INSTRUMENT RISK
//=============================================================================

ret                   = (close - close[1]) / close[1]
dailyPercentVolRecent = math.sqrt(ta.ema(math.pow(ret, 2), expoStdLength))
dailyPercentVol8Yr    = ta.sma(dailyPercentVolRecent, avgStdLength)
dailyPercentVol       = 0.7 * dailyPercentVolRecent + 0.3 * dailyPercentVol8Yr
instRisk              = math.round(dailyPercentVol * 16, 6)
dailyPriceVol         = dailyPercentVol * close

// Precomputed return moments â€” shared by all three capforecastSk calls (avoids
// 420 manual loop iterations/bar; ta.sma is an O(1) amortised rolling mean)
ret2 = ret * ret
ret3 = ret2 * ret

//=============================================================================
// Regime Detector (ER + Relative Vol + Autocorrelation, Multi-Speed)
//=============================================================================

GRP_RE      = 'Regime Settings'
float i_mult_strength = input.float(0.5, "Multiplier Strength (Â±)", minval=0.05, maxval=0.5, step=0.05, group=GRP_RE)
int   i_ema_smooth    = input.int(16, "EMA Smoothing", minval=1, maxval=100, group=GRP_RE)
int   i_norm_len      = input.int(252, "Percentile Rank Lookback", minval=50, maxval=2520, group=GRP_RE)
float i_w_er          = input.float(0.4, "Weight: ER", minval=0.0, maxval=1.0, step=0.05, group=GRP_RE)
float i_w_rvac        = input.float(0.6, "Weight: RelVol+AC", minval=0.0, maxval=1.0, step=0.05, group=GRP_RE)

//-----------------------------------------------------------------------------
// Efficiency Ratio (Kaufman): |net move| / sum(|bar moves|)
//-----------------------------------------------------------------------------
efficiencyRatio(int len) =>
    float direction  = math.abs(close - close[len])
    float volatility = math.sum(math.abs(close - close[1]), len)
    volatility > 0 ? direction / volatility : 0.5

erFast   = efficiencyRatio(16)
erMedium = efficiencyRatio(32)
erSlow   = efficiencyRatio(64)
erRaw    = (erFast + erMedium + erSlow) / 3.0

//-----------------------------------------------------------------------------
// Relative Vol + Autocorrelation
//-----------------------------------------------------------------------------
relVol_and_corr(fastCorLength) =>
    slowCorLength = fastCorLength * 4
    vol_fast = ta.stdev(close / close[1], fastCorLength) * math.sqrt(252)
    vol_slow = ta.stdev(close / close[1], slowCorLength) * math.sqrt(252)

    relative_vol = (not na(vol_fast) and not na(vol_slow) and vol_slow != 0.0) ? (vol_fast / vol_slow) : na
    autocorr = ta.correlation(close - close[1], close[1] - close[2], fastCorLength)

    rv_term = (not na(relative_vol)) ? (1.0 - math.min(relative_vol, 2.0) / 2.0) : na
    ac_term = (not na(autocorr)) ? ((math.max(autocorr, -1.0) + 1.0) / 2.0) : na

    trend_score = (not na(rv_term) and not na(ac_term)) ? (rv_term * 0.5 + ac_term * 0.5) : na

corFast   = relVol_and_corr(16)
corMedium = relVol_and_corr(32)
corSlow   = relVol_and_corr(64)
rvacRaw   = (corFast + corMedium + corSlow) / 3.0

//-----------------------------------------------------------------------------
// Normalize via percentile rank â†’ [0, 1]
//-----------------------------------------------------------------------------
float cntER   = 0.0
float cntRVAC = 0.0
for i = 1 to i_norm_len
    if erRaw   > erRaw[i]
        cntER   += 1.0
    if rvacRaw > rvacRaw[i]
        cntRVAC += 1.0
float scoreER   = cntER   / i_norm_len
float scoreRVAC = cntRVAC / i_norm_len

//-----------------------------------------------------------------------------
// Weighted combine â†’ trendingScore [0, 1]
//-----------------------------------------------------------------------------
float wSum = i_w_er + i_w_rvac
float trend_score = wSum > 0 ?
     (i_w_er * scoreER + i_w_rvac * scoreRVAC) / wSum : 0.5

//-----------------------------------------------------------------------------
// Multipliers: strength-based, EMA smoothed, clipped
//-----------------------------------------------------------------------------
float divRaw  = 1.0 + (trend_score - 0.5) * 2.0 * i_mult_strength
float convRaw = 1.0 - (trend_score - 0.5) * 2.0 * i_mult_strength

div_mult  = ta.ema(divRaw, i_ema_smooth)
conv_mult = ta.ema(convRaw, i_ema_smooth)

float multMin = 1.0 - i_mult_strength
float multMax = 1.0 + i_mult_strength
div_mult  := math.max(multMin, math.min(multMax, div_mult))
conv_mult := math.max(multMin, math.min(multMax, conv_mult))

regimeTotal    = (div_mult * 4) + (conv_mult * 2)
regimeTrending = div_mult / regimeTotal
regimeReverse  = conv_mult / regimeTotal

//=============================================================================
// BREADTH FORECAST (Level-Based)
//=============================================================================

advc = "(HIGN+HIGQ+HIGA)/3.0"
loc  = "(LOWN+LOWQ+LOWA)/3.0"

adv = request.security(mkt == "Combined" ? advc : mkt == "NYSE" ? "MAHN" : mkt == "NASDAQ" ? "MAHQ" : mkt == "AMEX" ? "MAHA" : advc, "D", close)
lo  = request.security(mkt == "Combined" ? loc  : mkt == "NYSE" ? "MALN" : mkt == "NASDAQ" ? "MALQ" : mkt == "AMEX" ? "MALA" : loc, "D", close)

den     = adv + lo
hli_raw = den != 0 ? (adv / den) * 100.0 : na
com_hli = (ta.ema(hli_raw, 16) + ta.ema(hli_raw, 32) + ta.ema(hli_raw, 64)) / 3.0

cappedForcBt = cap(((com_hli - 50.0) / 50.0) * brScalar)

//=============================================================================
// MOMENTUM FORECAST
//=============================================================================

momentumForcCal(int len, int multiplier) =>
    int emaLen = math.max(1, len * multiplier)
    ema_ = ta.ema(close, emaLen)

rapidEma   = momentumForcCal(8,  1)
rapidSEma  = momentumForcCal(8,  4)
fastEma    = momentumForcCal(16, 1)
fastSEma   = momentumForcCal(16, 4)
mediumEma  = momentumForcCal(32, 1)
mediumSEma = momentumForcCal(32, 4)
slowEma    = momentumForcCal(64, 1)
slowSEma   = momentumForcCal(64, 4)

scalForecastMo(float _fastEma, float _slowEma, float _volatility, float _scalar) =>
    (_fastEma - _slowEma) / (math.abs(_volatility) < 1e-10 ? 1e-10 : _volatility) * _scalar

scaledForcR = scalForecastMo(rapidEma,  rapidSEma,  dailyPriceVol, rapidMoScalar)
scaledForcF = scalForecastMo(fastEma,   fastSEma,   dailyPriceVol, fastMoScalar)
scaledForcM = scalForecastMo(mediumEma, mediumSEma, dailyPriceVol, mediumMoScalar)
scaledForcS = scalForecastMo(slowEma,   slowSEma,   dailyPriceVol, slowMoScalar)

cappedForcMo = (cap(scaledForcR) + cap(scaledForcF) + cap(scaledForcM) + cap(scaledForcS)) / 4.0

//=============================================================================
// ACCELERATION FORECAST
//=============================================================================

capForecastAc(int offsetLen, float _scaledForc, float forecastAcScalar) =>
    cap((_scaledForc - _scaledForc[offsetLen]) * forecastAcScalar)

cappedForcAc = (capForecastAc(16, scaledForcF, acFastScalar) + capForecastAc(32, scaledForcM, acMediumScalar) + capForecastAc(64, scaledForcS, acSlowScalar)) / 3.0

//=============================================================================
// BREAKOUT FORECAST
//=============================================================================

capForecastBo(int breakLen, float forecastScalar) =>
    hi      = ta.highest(high, breakLen)
    lo_     = ta.lowest(low, breakLen)
    rangeBo = hi - lo_
    boRaw   = rangeBo != 0.0 ? 40.0 * (close - (hi + lo_) / 2.0) / rangeBo : 0.0
    cap(ta.ema(boRaw, math.max(1, int(breakLen / 4))) * forecastScalar)

cappedForcBo = (capForecastBo(20, bo20Scalar) + capForecastBo(40, bo40Scalar) + capForecastBo(80, bo80Scalar)) / 3.0

//=============================================================================
// SKEW FORECAST
//=============================================================================

capforecastSk(int len, float scalar) =>
    int length = math.max(len, 2)
    float mean = ta.sma(ret,  length)
    float m2   = ta.sma(ret2, length)
    float m3   = ta.sma(ret3, length)
    float mu3      = m3 - 3.0 * mean * m2 + 2.0 * math.pow(mean, 3.0)
    float variance = m2 - mean * mean
    float stdv     = variance > 0 ? math.sqrt(variance) : na
    float skewForc = not na(stdv) and stdv != 0.0 ? -mu3 / math.pow(stdv, 3.0) : 0.0
    cap(ta.ema(skewForc, math.max(1, length / 4)) * scalar)

cappedForcSk = (capforecastSk(60, sk60Scalar) + capforecastSk(120, sk120Scalar) + capforecastSk(240, sk240Scalar)) / 3.0

//=============================================================================
// CARRY FORECAST
//=============================================================================

baseCrForc = adjExpectedDiv * crScalar / instRisk

capForecastCr(int smoothLen, float src) =>
    cap(ta.ema(src, smoothLen))

cappedForcCr = (capForecastCr(20, baseCrForc) + capForecastCr(60, baseCrForc) + capForecastCr(120, baseCrForc)) / 3.0

//=============================================================================
// COMBINED FORECAST + POSITION SIZING
//=============================================================================

combForc       = cappedForcMo * regimeTrending + cappedForcAc * regimeTrending + cappedForcBo * regimeTrending + cappedForcCr * regimeReverse + cappedForcSk * regimeReverse + cappedForcBt * regimeTrending
cappedCombForc = cap(combForc * forcastDiverMuliplier)
rawCombForc    = cappedCombForc / 10.0
adjCombForc    = capadj(rawCombForc)

// Position sizing
capitalRisk     = strategy.equity * mmRiskPct
basePos         = dailyPriceVol > 0 ? capitalRisk / dailyPriceVol : 0.0
optimalPosition = math.round(basePos * adjCombForc)

// Buffer zone â€” proportional to optimal position
bufferWidth = math.max(1.0, deviationChange * math.abs(optimalPosition))
lowerBuffer = math.round(optimalPosition - bufferWidth, 0)
upperBuffer = math.round(optimalPosition + bufferWidth, 0)
currentSize = strategy.position_size

// Available cash for incremental purchases
availCash = strategy.equity - (currentSize * close)

// --- Signals ---
needMore   = optimalPosition > 0 and currentSize < lowerBuffer
needLess   = currentSize > 0 and currentSize > upperBuffer
needExit   = currentSize > 0 and optimalPosition <= 0

// Quantities â€” for buys, clamp to what cash can cover so partial fills still execute
commRate      = 0.00165
idealQty      = needMore ? math.abs(math.round(lowerBuffer - currentSize, 0)) : needLess ? math.abs(math.round(currentSize - upperBuffer, 0)) : 0
affordableQty = availCash > 0 ? math.floor(availCash / (close * (1.0 + commRate))) : 0
deltaQty      = needMore ? math.min(idealQty, affordableQty) : idealQty

buySignal = needMore and deltaQty >= 1
trimLong  = needLess and deltaQty >= 1
exitLong  = needExit

// Current proportion
targetSize        = exitLong ? 0.0 : buySignal ? currentSize + deltaQty : trimLong ? currentSize - deltaQty : currentSize
currentProportion = math.round(targetSize * close / strategy.equity, 2)

//=============================================================================
// STRATEGY EXECUTION
//=============================================================================

if exitLong and inTimeWindow
    strategy.close_all(comment = 'Exit')
else if buySignal and inTimeWindow
    strategy.entry('B', strategy.long, qty = deltaQty)
else if trimLong and inTimeWindow
    strategy.close('B', qty = deltaQty, comment = 'Trim')

//=============================================================================
// PERFORMANCE METRICS
//=============================================================================

avgTradeDrawdown() =>
    int trades = strategy.closedtrades
    if trades == 0
        [na, na, na]
    else
        float sumAll = 0.0, float sumWin = 0.0, float sumLoss = 0.0
        int nWin = 0, int nLoss = 0
        for i = 0 to trades - 1
            posValue = math.abs(strategy.closedtrades.entry_price(i) * strategy.closedtrades.size(i))
            ddPerc   = posValue != 0 ? math.abs(strategy.closedtrades.max_drawdown(i)) / posValue : na
            if not na(ddPerc)
                sumAll += ddPerc
                if strategy.closedtrades.profit(i) >= 0
                    sumWin += ddPerc
                    nWin   += 1
                else
                    sumLoss += ddPerc
                    nLoss   += 1
        [trades > 0 ? sumAll / trades : na, nWin > 0 ? sumWin / nWin : na, nLoss > 0 ? sumLoss / nLoss : na]

[avgTradeDD, avgTradeWinDD, avgTradeLossDD] = avgTradeDrawdown()

// Annual Return
var int firstTradeTime = na
if strategy.opentrades + strategy.closedtrades > 0 and na(firstTradeTime)
    firstTradeTime := time

yearsActive     = (time - firstTradeTime) / (365.25 * 24 * 60 * 60 * 1000)
totReturn       = strategy.netprofit / strategy.initial_capital
avgAnnualReturn = yearsActive > 0 ? (math.pow(1.0 + totReturn, 1.0 / yearsActive) - 1.0) * 100 : na
avgDD           = avgTradeDD

// Sharpe Ratio
float barsPerYear = timeframe.isdaily ? 256.0 : timeframe.isweekly ? 52.0 : timeframe.ismonthly ? 12.0 : nz(256.0 * 390.0 / str.tonumber(timeframe.period), 0)

var float sumRet   = 0.0
var float sumSqRet = 0.0
var int   nRet     = 0

if not na(firstTradeTime) and time > firstTradeTime and not na(strategy.equity) and not na(strategy.equity[1]) and barsPerYear > 0
    r         = strategy.equity / strategy.equity[1] - 1.0
    sumRet   += r
    sumSqRet += r * r
    nRet     += 1

meanBar     = nRet > 0 ? sumRet / nRet : na
varBar      = nRet > 0 ? (sumSqRet / nRet) - meanBar * meanBar : na
stdBar      = not na(varBar) and varBar > 0 ? math.sqrt(varBar) : na
excess_bar  = not na(meanBar) ? meanBar - 0.01 / barsPerYear : na
sharpeRatio = not na(stdBar) and stdBar > 0 and not na(excess_bar) ? excess_bar / stdBar * math.sqrt(barsPerYear) : na

//=============================================================================
// TABLE & VISUALS
//=============================================================================

bgMColour = strategy.netprofit > 0 ? color.rgb(8, 153, 129) : color.rgb(242, 54, 69)
bgSColour = strategy.netprofit > 0 ? color.rgb(8, 153, 129, 20) : color.rgb(242, 54, 69, 20)

table_data = table.new(position = position.bottom_right, columns = 1, rows = 6, bgcolor = color.rgb(0, 0, 0, 100), frame_width = 1, border_width = 1)

table.cell(table_data, 0, 0, str.tostring(avgAnnualReturn, format.percent),           text_size = size.normal, bgcolor = bgMColour,                    text_color = color.white, text_halign = text.align_center, tooltip = 'Average Annual Return')
table.cell(table_data, 0, 1, str.tostring(math.round(sharpeRatio, 3)),                text_size = size.normal, bgcolor = bgSColour,                    text_color = color.white, text_halign = text.align_center, tooltip = 'Sharpe Ratio')
table.cell(table_data, 0, 2, str.tostring(avgDD * 100, format.percent),               text_size = size.normal, bgcolor = color.rgb(242, 54, 69, 30),   text_color = color.white, text_halign = text.align_center, tooltip = 'Average Drawdown per Trade')
string forecastText = str.tostring(math.round(adjCombForc, 2)) + (regimeTrending <= regimeReverse ? " â„ï¸" : "ðŸ”¥")
table.cell(table_data, 0, 3, forecastText, text_size = size.normal, bgcolor = color.rgb(255, 255, 255, 90), text_color = color.white, tooltip = 'Forecast' + (regimeTrending <= regimeReverse ? ' (Range-bound)' : ' (Trending)'))
table.cell(table_data, 0, 4, str.tostring(instRisk * 100, format.percent),            text_size = size.normal, bgcolor = color.rgb(242, 54, 70, 70),    text_color = color.white, text_halign = text.align_center, tooltip = 'Instrument Risk')
table.cell(table_data, 0, 5, str.tostring(currentProportion * 100, format.percent),   text_size = size.normal, bgcolor = color.rgb(255, 255, 255, 90),  text_color = color.white, tooltip = 'Percent Risk')

// Entry & Exit Signals
plotshape(buySignal and inTimeWindow, title = 'Buy / Add', text = 'â–²', textcolor = color.white, style = shape.labelup,   location = location.belowbar, color = color.rgb(8, 153, 129, 70), size = size.tiny)
plotshape((trimLong or exitLong) and inTimeWindow, title = 'Trim / Exit', text = 'âœ˜', textcolor = color.white, style = shape.labeldown, location = location.abovebar, color = color.rgb(242, 54, 69, 70), size = size.tiny)

// Alert
if buySignal and inTimeWindow
    alert('Buy', alert.freq_once_per_bar_close)
else if (trimLong or exitLong) and inTimeWindow
    alert('Trim/Exit', alert.freq_once_per_bar_close)
