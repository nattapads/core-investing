//NSal
//@version=6
indicator('[IND] Advance Momentum + Volatility',  overlay = true)

//-----------------------------------------------------------------------------}
//Stochastic Settings
//-----------------------------------------------------------------------------{
vline_hh = input.bool(true, title = 'Vline Highest')
vline_ll = input.bool(true, title = 'Vline Lowest')

periodK1 = input.int(9, title = '%K 1 Length', minval = 1)
smoothK1 = input.int(1, title = '%K 1 Smoothing', minval = 1)
periodD1 = input.int(3, title = '%D 1 Smoothing', minval = 1)

periodK2 = input.int(14, title = '%K 2 Length', minval = 1)
smoothK2 = input.int(1, title = '%K 2 Smoothing', minval = 1)
periodD2 = input.int(3, title = '%D 2 Smoothing', minval = 1)

periodK3 = input.int(40, title = '%K 3 Length', minval = 1)
smoothK3 = input.int(1, title = '%K 3 Smoothing', minval = 1)
periodD3 = input.int(4, title = '%D 3 Smoothing', minval = 1)

periodK4 = input.int(60, title = '%K 4 Length', minval = 1)
smoothK4 = input.int(1, title = '%K 4 Smoothing', minval = 1)
periodD4 = input.int(10, title = '%D 4 Smoothing', minval = 1)

buyThreshold = input.int(20, title = 'Buy Threshold', minval = 1)
sellThreshold = input.int(80, title = 'Buy Threshold', minval = 1)

var array<float> high_tracking = na
var array<float> low_tracking = na

// Store previous turning points to avoid repeated notifications
var float prev_hh = na
var float prev_ll = na

// Function to track highest and lowest points
track_high_low(_src) =>
    hh_index = ta.highestbars(_src, 14)
    ll_index = ta.lowestbars(_src, 14)
    [hh_index, ll_index]

// Get the highest and lowest points based on the selected timeframe
[hh_index, ll_index] = track_high_low(close)

//-----------------------------------------------------------------------------}
//Stochastic Calculation
//-----------------------------------------------------------------------------{
k1 = ta.sma(ta.stoch(close, high, low, periodK1), smoothK1)
d1 = ta.sma(k1, periodD1)

k2 = ta.sma(ta.stoch(close, high, low, periodK2), smoothK2)
d2 = ta.sma(k2, periodD2)

k3 = ta.sma(ta.stoch(close, high, low, periodK3), smoothK3)
d3 = ta.sma(k3, periodD3)

k4 = ta.sma(ta.stoch(close, high, low, periodK4), smoothK4)
d4 = ta.sma(k4, periodD4)

//-----------------------------------------------------------------------------}
//Line Colour
//-----------------------------------------------------------------------------{
var strBullColour = color.rgb(8, 153, 129)
var bullColour = color.rgb(8, 153, 129, 50)
var strbearColour = color.rgb(242, 54, 69)
var bearColour = color.rgb(242, 54, 70, 50)

//-----------------------------------------------------------------------------}
//SetUp Calculation
//-----------------------------------------------------------------------------{
strBullish = d4 <= buyThreshold and d3 <= buyThreshold and d2 <= buyThreshold and d1 <= buyThreshold
bullish = d4 <= buyThreshold and d3 <= buyThreshold and d2 <= buyThreshold

strBearish = d4 >= sellThreshold and d3 >= sellThreshold and d2 >= sellThreshold and d1 >= sellThreshold
bearish = d4 >= sellThreshold and d3 >= sellThreshold and d2 >= sellThreshold

//-----------------------------------------------------------------------------}
//HH & LL Calculation
//-----------------------------------------------------------------------------{
newHigh = vline_hh and hh_index >= 0
newLow = vline_ll and ll_index >= 0

//-----------------------------------------------------------------------------
// Track combined conditions for Short plot
//-----------------------------------------------------------------------------
var bool bothBearishHappened = false
var bool plotShort = false

// Check if both strBearish and newHigh happen at the same time
if strBearish and newHigh
    bothBearishHappened := true
    bothBearishHappened

// Condition to plot the circle when newLow occurs after bothBearishHappened is true
plotShort := bothBearishHappened and newLow

if plotShort
    bothBearishHappened := false
    bothBearishHappened

//-----------------------------------------------------------------------------
// Track combined conditions for Long plot
//-----------------------------------------------------------------------------
var bool bothBullishHappened = false
var bool plotLong = false

// Check if both strBullish and newLow happen at the same time
if strBullish and newLow
    bothBullishHappened := true
    bothBullishHappened

// Condition to plot the square when newHigh occurs after bothBullishHappened is true
plotLong := bothBullishHappened and newHigh

if plotLong
    bothBullishHappened := false
    bothBullishHappened

//-----------------------------------------------------------------------------
// Plot Circle and Square
//-----------------------------------------------------------------------------
plotshape(plotShort, style = shape.triangledown, location = location.abovebar, color = strbearColour, size = size.tiny)
plotshape(plotLong, style = shape.triangleup, location = location.belowbar, color = strBullColour, size = size.tiny)

//-----------------------------------------------------------------------------
//Color Styles
//-----------------------------------------------------------------------------
strongbullColor = color.rgb(8, 153, 129)
strongBearishColor = color.rgb(242, 54, 69)
neutralColor = color.rgb(255, 255, 255, 80)

//-----------------------------------------------------------------------------
//Input Group
//-----------------------------------------------------------------------------
var string momentum_settings    = "Momentum Settings"
var string sensitivity_settings = "Sensitivity Settings"
var string visual_settings      = "Visual Settings"

//-----------------------------------------------------------------------------}
//Risk Settings
//-----------------------------------------------------------------------------{
expoStdLength = input.int(32, title = 'Exponential SD Length', group = 'Risk Settings')
fastLength = input.int(5, title = 'Fast SD Length', group = 'Risk Settings')
slowLength = input.int(20, title = 'Slow SD Length', group = 'Risk Settings')

//-----------------------------------------------------------------------------{
//Instrument Risk Calculation
//-----------------------------------------------------------------------------{
// Percentage returns
ret = (close - close[1]) / close[1]
var float dailyPercentVolRecent = na

ew_var = ta.ema(math.pow(ret, 2), expoStdLength)
dailyPercentVolRecent := math.sqrt(ew_var)

// Long-term vol  (8-year ≈ 2 000 bars)
longWindow = 2000           // author uses 10y; we use 8y per requirement
dailyPercentVol8Yr = ta.sma(dailyPercentVolRecent, longWindow)

// Weighted blend 70 / 30
dailyPercentVol = 0.7 * dailyPercentVolRecent + 0.3 * dailyPercentVol8Yr

// Instrument risk & price-vol units (same as original)
instRisk      = math.round(dailyPercentVol * 16, 6)
dailyPriceVol = dailyPercentVol * close

fastVol   = ta.ema(ta.ema(dailyPriceVol, fastLength), fastLength)
slowVol   = ta.ema(ta.ema(dailyPriceVol, slowLength), slowLength)
diffVol = fastVol - slowVol

length = input.int(20, title = 'Difference Length', minval=1, group = 'Risk Settings')
maType = input.string("SMA", "Basis MA Type", options = ["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group = 'Risk Settings')
src = input(close, title="Source", group = 'Risk Settings')
mult = input.float(2.0, minval=0.001, maxval=50, title="StdDev", group = 'Risk Settings')

maa(source, length, _type) =>
    switch _type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "SMMA (RMA)" => ta.rma(source, length)
        "WMA" => ta.wma(source, length)
        "VWMA" => ta.vwma(source, length)

basis = maa(diffVol, length, maType)
dev = mult * ta.stdev(diffVol, length)
upper = basis + dev
lower = basis - dev

crossUp = ta.crossover(diffVol, upper)
crossDn = ta.crossunder(diffVol, lower)

var color flatColour = color.rgb(120, 123, 134, 60)

// persistent trend colour (starts neutral, flips only on signals)
var color trendColour = flatColour
if crossUp
    trendColour := strongbullColor
else if crossDn
    trendColour := strongBearishColor

//-----------------------------------------------------------------------------
//S&P500 Buy & Sell Zone
//-----------------------------------------------------------------------------
asset = input.symbol(title = 'Primary Source', defval = 'S5TH', inline = 'source', group = 'S&P500 Buy & Sell Zone')
buyThe = input(30, title = 'S&P500 Buy Threshold', group = 'S&P500 Buy & Sell Zone')
sellThe = input(70, title = 'S&P500 Sell Threshold', group = 'S&P500 Buy & Sell Zone')
sp500 = request.security(asset, 'W', close)

assetBuy = ta.crossover(sp500, 20)
assetSell = ta.crossunder(sp500, 80)

// Color
colorMa = sp500 < buyThe ? strongbullColor : sp500 > sellThe ? strongBearishColor : neutralColor


//-----------------------------------------------------------------------------
// Hindenburg Omen
//-----------------------------------------------------------------------------

new_low_high_threshold = input(2.2, title = 'New Lows/Highs Threshold (Cond 1) %')
pos_trend_lookback = input(50, title = 'Positive Trend Lookback (Cond 2)')

//////////////
// GET DATA //

nyse_adv = request.security('USI:ADV', 'D', close) // Count of Advancing Issues (NYSE)
nyse_unc = request.security('USI:UNCH.NY', 'D', close) // Count of Unchanged Issues (NYSE)
nyse_dec = request.security('USI:DECL', 'D', close) // Count of Declining Issues (NYSE)

nyse_newh = request.security('INDEX:MAHN', 'D', close) // Count of Issues Hitting 52Week Highs (NYSE)
nyse_newl = request.security('INDEX:MALN', 'D', close) // Count of Issues Hitting 52Week Lows  (NYSE)
nyse_comp_indx = request.security('NYA', 'D', close) // NYSE Composite Index Value


//////////////////
// CALCULATIONS //

// Condition 1: 
// % of Issues of hitting New 52W highs and 52W lows is greater than or equal to a threshold (ex 2.8%)

//Total Number of Issues
total = nyse_adv + nyse_dec + nyse_unc

cond1 = nyse_newh / total * 100 >= new_low_high_threshold and nyse_newl / total * 100 >= new_low_high_threshold

newh_perc_str = str.tostring(math.round(nyse_newh / total * 1000) / 10)
newl_perc_str = str.tostring(math.round(nyse_newl / total * 1000) / 10)


// Condition 2: 
// Index is higher or equal in value than when it was 50 days ago.

cond2 = nyse_comp_indx >= nyse_comp_indx[pos_trend_lookback]

// Condition 3: 
// McClelland Oscillator must be negative.

//McClelland Oscillator
rana = 1000 * ((nyse_adv - nyse_dec) / (nyse_adv + nyse_dec))
mcc_ma1 = ta.ema(rana, 19)
mcc_ma2 = ta.ema(rana, 39)
mcc = mcc_ma1 - mcc_ma2

cond3 = mcc < 0

// Condition 4: 
// The ratio of New 52W Highs to New 52W Lows cannot exceed 2
cond4 = nyse_newh / nyse_newl < 2

//Hindenburg Condition
//All four conditions are met
ho_cond = cond1 and cond2 and cond3 and cond4

cond_num = (cond1 ? 1 : 0) + (cond2 ? 1 : 0) + (cond3 ? 1 : 0) + (cond4 ? 1 : 0)

//Hindenburg Omen Signal Period of 30 days
//bgcolor(ta.barssince(ho_cond) <= 30 ? color.rgb(242, 54, 69, 80) : na)
badOmen = ta.barssince(ho_cond) <= 30

//-----------------------------------------------------------------------------}
//Elher
//-----------------------------------------------------------------------------{
elhSrc = input(hl2, title = 'Source')
lvls = input(0.8, title = 'OB/OS Level')

f_ehlers_v2(_src, _len) =>
    float nm = 0.0
    float dm = 0.0
    for i = 0 to _len - 1 by 1
        nm += (1 + i) * _src[i]
        dm += _src[i]

    cg   = dm != 0 ? -nm / dm + (_len + 1) / 2.0 : 0.0
    maxc = ta.highest(cg, _len)
    minc = ta.lowest(cg, _len)
    v1   = maxc != minc ? (cg - minc) / (maxc - minc) : 0.0

    v2_  = (4 * v1 + 3 * v1[1] + 2 * v1[2] + v1[3]) / 10.0
    v2   = 2 * (v2_ - 0.5)
    v2

mediumEhl = f_ehlers_v2(elhSrc, 128)
slowEhl = f_ehlers_v2(elhSrc, 256)

allElher = array.from(mediumEhl, slowEhl)
avgElher = array.avg(allElher)

l1 = -math.abs(lvls)

badElher = avgElher < l1

leadCon = badOmen and badElher
leadEither = badOmen or badElher

//-----------------------------------------------------------------------------}
//Moving Average
//-----------------------------------------------------------------------------{
smoothMa = input(false, title = 'Smooth MA', group = 'EMA Settings')

ma(source, length, type) =>
    type == 'SMA' ? ta.sma(source, length) : type == 'EMA' ? ta.ema(source, length) : type == 'SMMA (RMA)' ? ta.rma(source, length) : type == 'WMA' ? ta.wma(source, length) : type == 'VWMA' ? ta.vwma(source, length) : na

show_ma3 = input(true, 'MA №3', inline = 'MA #3', display = display.data_window, group = 'EMA Settings')
ma3_type = input.string('EMA', '', inline = 'MA #3', options = ['SMA', 'EMA', 'SMMA (RMA)', 'WMA', 'VWMA'], group = 'EMA Settings')
ma3_source = input(close, '', inline = 'MA #3', display = display.data_window, group = 'EMA Settings')
ma3_length = input.int(40, '', inline = 'MA #3', minval = 1, group = 'EMA Settings')
ma3_color = input(color.rgb(8, 153, 129), '', inline = 'MA #3', display = display.data_window, group = 'EMA Settings')
ma3 = ma(ma3_source, ma3_length, ma3_type)
ma3mo = smoothMa ? ma(ma3, ma3_length, ma3_type) : ma3

show_ma4 = input(true, 'MA №4', inline = 'MA #4', display = display.data_window, group = 'EMA Settings')
ma4_type = input.string('EMA', '', inline = 'MA #4', options = ['SMA', 'EMA', 'SMMA (RMA)', 'WMA', 'VWMA'], group = 'EMA Settings')
ma4_source = input(close, '', inline = 'MA #4', display = display.data_window, group = 'EMA Settings')
ma4_length = input.int(89, '', inline = 'MA #4', minval = 1, group = 'EMA Settings')
ma4_color = input(color.rgb(242, 54, 69), '', inline = 'MA #4', display = display.data_window, group = 'EMA Settings')
ma4 = ma(ma4_source, ma4_length, ma4_type)
ma4mo = smoothMa ? ma(ma4, ma4_length, ma4_type) : ma4
plot(show_ma4 ? ma4mo : na, color = leadCon ? strbearColour : leadEither ? bearColour : sp500 < buyThe ? strBullColour : sp500 < buyThe and leadCon ? bullColour : sp500 < buyThe and leadEither ? bullColour : neutralColor, title = 'MA №4', linewidth = 2)

plotshape(assetBuy ? ma4mo : na, title = 'Buy', style = shape.circle, location = location.absolute, color = strongbullColor, size = size.tiny)
plotshape(assetSell ? ma4mo : na, title = 'Sell', style = shape.circle, location = location.absolute, color = strongBearishColor, size = size.tiny)

//-----------------------------------------------------------------------------
//MACD
//-----------------------------------------------------------------------------
[macdLine, signalLine, _] = ta.macd(close, 12, 26, 9)

//MACD cross conditions
macdCrossOver = ta.crossover(macdLine, signalLine)
macdCrossUnder = ta.crossunder(macdLine, signalLine)

//Highlight bar Green: MACD > 0 and Signal < 0
greenBar = macdLine > 0 and signalLine < 0
redBar = macdLine < 0 and signalLine > 0
//barcolor(greenBar ? strongbullColor : redBar ? strongBearishColor : na, title = 'Bar Highlight Green')

//-----------------------------------------------------------------------------
//Three Conservative Bar
//-----------------------------------------------------------------------------
threeBull = close[1] > close[2] and close[2] > close[3] and close[0] > close[1] and close[0] > open[0] and close[1] > open[1] and close[2] > open[2]
threeBear = close[1] < close[2] and close[2] < close[3] and close[0] < close[1] and close[0] < open[0] and close[1] < open[1] and close[2] < open[2]

//barcolor(threeBull ? strongbullColor : threeBear ? strongBearishColor : neutralColor, title = 'Bar Highlight')

//-----------------------------------------------------------------------------}
//Advanced Momentum Settings
//-----------------------------------------------------------------------------{
//EMA Settings
ultra_fast = input.int(34, title = 'Ultra-Fast EMA', 
     minval = 1, 
     group = momentum_settings)
     
fast = input.int(55, title = 'Fast EMA', 
     minval = 1, 
     group = momentum_settings)
     
mid = input.int(89, title = 'Mid EMA', 
     minval = 1, 
     group = momentum_settings)
     
slow = input.int(144, title = 'Slow EMA', 
     minval = 1, 
     group = momentum_settings)
     
series float price = input.source(close, 'Price Source', 
     group = momentum_settings)

// Momentum Settings
roc_period = input.int(5, title = 'RoC Period', 
     minval = 1, 
     group = momentum_settings)
     
mom_threshold = input.float(0.5, title = 'Momentum Threshold (%)', 
     step = 0.1, 
     group = momentum_settings)

// Sensitivity Settings
mode = input.string('Balanced', 'Sensitivity Mode', 
     options = ['Conservative', 'Balanced', 'Aggressive'], 
     group = sensitivity_settings)

// Visual Settings
up_color = strongbullColor
down_color = strongBearishColor
neutral_color = neutralColor

//-----------------------------------------------------------------------------
// Momentum Calculation
//-----------------------------------------------------------------------------
// Constant settings
const int   atr_len = 14
const float vol_thresh = 1.5
const int   rsi_len = 10
const int   rsi_high = 70
const int   rsi_low = 30
const bool  use_volume = true
const int   vol_len = 20
const int   bar_transp = 40
const int   max_intensity = 20

// EMAs
ema_ultra = ta.ema(price, ultra_fast)
ema_fast = ta.ema(price, fast)
ema_mid = ta.ema(price, mid)
ema_slow = ta.ema(price, slow)

// EMA slopes for trend momentum
slope_ultra = (ema_ultra - ema_ultra[1]) / ema_ultra[1] * 100
slope_fast = (ema_fast - ema_fast[1]) / ema_fast[1] * 100
slope_mid = (ema_mid - ema_mid[1]) / ema_mid[1] * 100

// Rate of Change for early trend detection
roc = (close - close[roc_period]) / close[roc_period] * 100
roc_smooth = ta.sma(roc, 3) // Smoothed RoC

// Dynamic volatility threshold based on sensitivity mode
var float dyn_thresh = vol_thresh
if mode == 'Conservative'
    dyn_thresh := vol_thresh * 1.2
else if mode == 'Aggressive'
    dyn_thresh := vol_thresh * 0.8
else
    dyn_thresh := vol_thresh

// Early Trend Direction (more sensitive)
early_up = ema_ultra > ema_fast and slope_fast > 0 and roc_smooth > mom_threshold
early_down = ema_ultra < ema_fast and slope_fast < 0 and roc_smooth < -mom_threshold

// Confirmed Trend Direction (more reliable)
confirm_up = ema_fast > ema_mid and ema_mid > ema_slow and close > ema_fast
confirm_down = ema_fast < ema_mid and ema_mid < ema_slow and close < ema_fast

// Final Trend Direction (based on sensitivity mode)
bool trend_up = false
bool trend_down = false
bool trend_neutral = false

if mode == 'Conservative'
    trend_up := confirm_up
    trend_down := confirm_down
    trend_neutral := not confirm_up and not confirm_down
else if mode == 'Aggressive'
    trend_up := early_up or ema_ultra > ema_fast and confirm_up
    trend_down := early_down or ema_ultra < ema_fast and confirm_down
    trend_neutral := not trend_up and not trend_down
else // Balanced
    trend_up := early_up and ema_fast > ema_mid or confirm_up
    trend_down := early_down and ema_fast < ema_mid or confirm_down
    trend_neutral := not trend_up and not trend_down

//-----------------------------------------------------------------------------
// Momentum Visualisation
//-----------------------------------------------------------------------------
// Calculate bands that cover the price bars automatically
calcBands() =>
    lookback = 10 // Number of bars to look back for determining range
    high_price = ta.highest(high, lookback)
    low_price = ta.lowest(low, lookback)

    middle = (high_price + low_price) / 2

    [middle]

[middle_band] = calcBands()

// Plot the main trend line with simple up/down/neutral color
//plot(middle_band, 'Trend', color = trend_up ? up_color : trend_down ? down_color : neutral_color, linewidth = 2)
dotColour = trend_up ? up_color : trend_down ? down_color : color.rgb(255, 255, 255)

plot(show_ma3 ? ma3mo : na, color = trend_up ? up_color : trend_down ? down_color : neutral_color, title = 'MA №3')
plotshape(crossUp ? ma3mo : na, title='New Highest exSD', style=shape.circle, location=location.absolute, color=dotColour, size = size.tiny)
plotshape(crossDn ? ma3mo : na, title='New Lowest exSD', style=shape.xcross, location=location.absolute, color=color.rgb(117, 117, 117), size = size.tiny)
barcolor(trend_up ? strongbullColor : trend_down ? strongBearishColor : neutralColor, title = 'Bar Highlight')

// Trend text and colors
trend_text = trend_up ? 'UPTREND' : trend_down ? 'DOWNTREND' : 'NEUTRAL'
color current_color = trend_up ? up_color : trend_down ? down_color : #555555

// Function to determine if a color is dark or light for contrast
isDarkColor(c) =>
    // Extract RGB components
    r = color.r(c)
    g = color.g(c)
    b = color.b(c)

    // Formula to determine brightness (weighted RGB)
    luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255

    // Return true if dark, false if light
    luminance < 0.5

//-----------------------------------------------------------------------------}
//Alert
//-----------------------------------------------------------------------------{
if crossUp
    alert("High Volatility", alert.freq_once_per_bar_close)
